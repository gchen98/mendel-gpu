
      MODULE MATRIX_COMPLETION_ROUTINES
!
!     THIS MODULE PERFORMS GENOTYPE IMPUTATION VIA MATRIX COMPLETION.
!
      USE CONSTANTS
      USE LOCUS_AND_PEDIGREE_STRUCTURES
      USE TOOLS
      USE INPUT_ROUTINES
      USE INPUT_DATA
      USE RANDOM_SAMPLE
      USE LINEAR_ALGEBRA
      USE OPTION_SUPPORTING_ROUTINES
!
      IMPLICIT NONE
!
      CONTAINS
!
      SUBROUTINE MATRIX_COMPLETION_IMPUTATION()
!
!     THIS SUBROUTINE CONDUCTS GENOTYPE IMPUTATION BY APPLYING
!     FISTA ACCELERATED SVT TO A SEQUENCE OF SLIDING WINDOWS OF SNPS.
!
      IMPLICIT NONE
      INTEGER :: K,L,REGION,REGIONS,Q,SNP_END,SNP_START,TYPED_PEOPLE
      LOGICAL :: SUB_ERROR
      INTEGER, DIMENSION(:,:), ALLOCATABLE :: BOUNDARY
      REAL(KIND=DBLE_PREC) :: VALIDATION_FRACTION
!
!     ***TUNABLE PARAMETER***
!     SET WINDOW SIZE PARAMETER AND VALIDATION FRACTION.
!
      Q = 100
      VALIDATION_FRACTION = 0.1
!
!     CHECK THAT ALL LOCI ARE SNPS WHEN USING STANDARD INPUT FILES.
!
    IF (SNP_BINARY_FILES) THEN
        TOTAL_SNPS = BINARY_SNPS
    ELSE
        IF (VERBOSE) WRITE(*,"(/(A))") &
        " *** ERROR *** FOR THIS VERSION WE ASSUME BINARY FILES."
        WRITE(OUTPUT_UNIT,"(/(A))") &
        " *** ERROR *** FOR THIS VERSION WE ASSUME BINARY FILES."
        WRITE(OUTPUT_UNIT,"(/(A))") " MENDEL TERMINATED!"
        STOP_PROGRAM = .TRUE.
        RETURN
    END IF
!
!     CHECK IF ANY ANALYSIS IS NECESSARY.
!
      IF (.NOT.MISSING_SNP_BIT_DATA) THEN
         IF (VERBOSE) WRITE(*,"(/(A))") &
            " *** WARNING *** SINCE THE INPUT INCLUDED NO MISSING SNP GENOTYPES,", &
            " NO SNP GENOTYPE IMPUTATION ANALYSIS WAS PERFORMED."
         WRITE(SUMMARY_UNIT,"(/(A))") &
            " *** WARNING *** SINCE THE INPUT INCLUDED NO MISSING SNP GENOTYPES,", &
            " NO SNP GENOTYPE IMPUTATION ANALYSIS WAS PERFORMED." 
         WRITE(OUTPUT_UNIT,"(/(A))") &
            " *** WARNING *** SINCE THE INPUT INCLUDED NO MISSING SNP GENOTYPES,", &
            " NO SNP GENOTYPE IMPUTATION ANALYSIS WAS PERFORMED."
         STOP_PROGRAM = .TRUE.
         RETURN
      END IF
!
!     CHECK THAT SOME SNPS ARE AVAILABLE.
!
      IF (TOTAL_SNPS==0) THEN
         IF (VERBOSE) WRITE(*,"(/(A))") &
            " *** WARNING *** NO GENOTYPES WERE IMPUTED", &
            " SINCE NO SNPS WERE AVAILABLE."
         WRITE(SUMMARY_UNIT,"(/(A))") &
            " *** WARNING *** NO GENOTYPES WERE IMPUTED", &
            " SINCE NO SNPS WERE AVAILABLE."
         WRITE(OUTPUT_UNIT,"(/(A))") &
            " *** WARNING *** NO GENOTYPES WERE IMPUTED", &
            " SINCE NO SNPS WERE AVAILABLE."
         STOP_PROGRAM = .TRUE.
         RETURN
      END IF
!
!     CHECK THAT EITHER ALL SNPS ARE AUTOSOMAL OR ALL ARE XLINKED.
!
      IF (.NOT.(ALL_SNPS_AUTOSOMAL.OR.ALL_SNPS_XLINKED)) THEN
         IF (VERBOSE) WRITE(*,"(/(A))") &
            " *** ERROR *** FOR THE GENOTYPE IMPUTATION ANALYSIS OPTION", &
            " EITHER ALL SNPS MUST BE AUTOSOMAL OR ALL MUST BE X-LINKED.", &
            " PLEASE USE THE FILE CONVERSION OPTION TO CREATE TWO BINARY SNP DATA SETS,", &
            " ONE WITH THE AUTOSOMAL SNPS, AND ONE WITH THE X-LINKED SNPS.", &
            " MENDEL TERMINATED!"
         WRITE(SUMMARY_UNIT,"(/(A))") &
            " *** ERROR *** FOR THE GENOTYPE IMPUTATION ANALYSIS OPTION", &
            " EITHER ALL SNPS MUST BE AUTOSOMAL OR ALL MUST BE X-LINKED.", &
            " PLEASE USE THE FILE CONVERSION OPTION TO CREATE TWO BINARY SNP DATA SETS,", &
            " ONE WITH THE AUTOSOMAL SNPS, AND ONE WITH THE X-LINKED SNPS.", &
            " MENDEL TERMINATED!"
         WRITE(OUTPUT_UNIT,"(/(A))") &
            " *** ERROR *** FOR THE GENOTYPE IMPUTATION ANALYSIS OPTION", &
            " EITHER ALL SNPS MUST BE AUTOSOMAL OR ALL MUST BE X-LINKED.", &
            " PLEASE USE THE FILE CONVERSION OPTION TO CREATE TWO BINARY SNP DATA SETS,", &
            " ONE WITH THE AUTOSOMAL SNPS, AND ONE WITH THE X-LINKED SNPS.", &
            " MENDEL TERMINATED!"
         STOP_PROGRAM = .TRUE.
         RETURN
!
!     CHECK IF SNP GENOTYPES ARE UNPHASED.
!
         IF (.NOT.ALL_UNPHASED) THEN
            IF (VERBOSE) WRITE(*,"(/(A))") &
               " *** ERROR *** ONLY UNPHASED SNP GENOTYPES ", &
              " ARE ALLOWED. MENDEL TERMINATED!"
            WRITE(SUMMARY_UNIT,"(/(A))") &
               " *** ERROR *** ONLY UNPHASED SNP GENOTYPES ", &
              " ARE ALLOWED. MENDEL TERMINATED!"
            WRITE(OUTPUT_UNIT,"(/(A))") &
               " *** ERROR *** ONLY UNPHASED SNP GENOTYPES ", &
              " ARE ALLOWED. MENDEL TERMINATED!"
            STOP_PROGRAM = .TRUE.
            RETURN
         END IF
      END IF
!
!     DETERMINE THE NUMBER OF GENOMIC REGIONS.
!
      REGIONS = COUNT(SNP_LOCUS%LINKAGE_BREAK)
      TYPED_PEOPLE = TOTAL_TYPED_AT_SNPS
!
!     FLAG THE CHROMOSOME REGIONS.
!
      ALLOCATE(BOUNDARY(2,REGIONS))
      K = 0
      DO L = 1,BINARY_SNPS
         IF (SNP_LOCUS(L)%LINKAGE_BREAK) THEN
            K = K+1
            BOUNDARY(1,K) = L
            IF (K>1) BOUNDARY(2,K-1) = L-1
         END IF
      END DO
      BOUNDARY(2,REGIONS) = BINARY_SNPS
!
!     LOOP OVER ALL REGIONS.
!
      DO REGION = 1,REGIONS
         SNP_START = BOUNDARY(1,REGION)
         SNP_END = BOUNDARY(2,REGION)
         CALL SLIDING_WINDOW(VALIDATION_FRACTION,SNP_START,SNP_END,Q,TYPED_PEOPLE)
      END DO
!
!     CREATE A NEW SNP DEFINITION FILE. THIS NEW FILE WILL HAVE
!     DIFFERENT DATA THAN THE ORIGINAL FILE ONLY IF ANY SNPS WERE FILTERED OR EXCLUDED,
!     I.E., ONLY IF (SNPS_TO_ANALYZE/=BINARY_SNPS).
!
      WRITE(NEW_SNP_DEF_UNIT,"(F8.2,A)") &
         SNP_FILE_VERSION,"  = FILE FORMAT VERSION NUMBER."
      WRITE(NEW_SNP_DEF_UNIT,"(I8,A)") &
         SNPS_TO_ANALYZE,"  = NUMBER OF SNPS LISTED HERE."
      CALL WRITE_BINARY_SNPS_TO_SNP_DEF
!
!     WRITE OUT THE BINARY SNP DATA FILE.
!
      CALL WRITE_BINARY_SNPS_TO_DATA_FILE(TYPED_PEOPLE,SNP_BIT,SNP_BIT_PHASE,SUB_ERROR)
      IF (SUB_ERROR) THEN
         IF (VERBOSE) WRITE(*,"(/(A))") &
            " *** ERROR *** PROBLEM WRITING THE NEW SNP DATA FILE " &
            //TRIM(NEW_SNP_DATA_FILE)," MENDEL TERMINATED!"
         WRITE(OUTPUT_UNIT,"(/(A))") &
            " *** ERROR *** PROBLEM WRITING THE NEW SNP DATA FILE " &
            //TRIM(NEW_SNP_DATA_FILE)," MENDEL TERMINATED!"
         STOP_PROGRAM = .TRUE.
         RETURN
      END IF
!
!     CLOSE DOWN.
!
      CLOSE(NEW_SNP_DATA_UNIT)
      CLOSE(NEW_SNP_PHASE_UNIT,STATUS="DELETE")
      NEW_SNP_PHASE_FILE = " "
      FINISHED_PROGRAM = .TRUE.
      END SUBROUTINE MATRIX_COMPLETION_IMPUTATION
!
      SUBROUTINE SLIDING_WINDOW(VALIDATION_FRACTION,M,N,Q,TYPED_PEOPLE)
!
!     THIS SUBROUTINE PERFORMS MATRIX COMPLETION OVER A SLIDING WINDOW.
!     SNP_START IS THE START SNP INDEX, SNP_END IS THE STOP SNP INDEX, AND
!     Q IS THE NUMBER OF SNPS IN A SUBWINDOW. VALIDATION_FRACTION IS THE FRACTION OF OBSERVED ENTRIES 
!     TO BE USED AS A VALIDATION SET.  THE CURRENT CODE ASSUMES THAT 
!     THE DESIRED NUMBER OF VALIDATION
!     ENTRIES CAN BE ACCOMODATED BY THE FLANKING SUBWINDOWS. 
!
      IMPLICIT NONE
      INTEGER :: I,J,M,N,N_SHIFTS,NSNPS,P,Q,R
      INTEGER :: SNP_READ_END,SNP_READ_START,SNP_WRITE_END,SNP_WRITE_START,TYPED_PEOPLE
      REAL(KIND=DBLE_PREC) :: RHO,VALIDATION_FRACTION
      INTEGER, DIMENSION(2*Q) :: COLUMN_OMIT
      REAL(KIND=DBLE_PREC), DIMENSION(M:N) :: SNP_FREQUENCY
      INTEGER, DIMENSION(3*Q*TYPED_PEOPLE) :: COLUMN, ROW
      REAL(KIND=DBLE_PREC), DIMENSION(TYPED_PEOPLE,3*Q) :: W,X,Z,Xt
      REAL(KIND=DBLE_PREC), DIMENSION(:,:), ALLOCATABLE :: W_LAST,X_LAST,Z_LAST
      REAL(KIND=DBLE_PREC), DIMENSION(387,103) :: HC
      LOGICAL :: SUB2_ERROR
!
      RHO = HALF
      N_SHIFTS = INT((N-M+1)/Q)-3
!
!     CODE CURRENTLY ASSUMES THAT THERE ARE ENOUGH SNPS TO SPAN 3 SUBWINDOWS
!
      NSNPS = 3*Q
      IF (NSNPS > N-M+1) THEN
         IF (VERBOSE) WRITE(*,"(/(A))") &
           " *** ERROR *** 3 SUBWINDOWS EXCEEDS SNP WINDOW LENGTH ", &
           " MENDEL TERMINATED!"
         WRITE(SUMMARY_UNIT,"(/(A))") &
           " *** ERROR *** 3 SUBWINDOWS EXCEEDS SNP WINDOW LENGTH ", &
           " MENDEL TERMINATED!"
         WRITE(OUTPUT_UNIT,"(/(A))") &
           " *** ERROR *** 3 SUBWINDOWS EXCEEDS SNP WINDOW LENGTH ", &
           " MENDEL TERMINATED!"
         STOP_PROGRAM = .TRUE.
         RETURN
      END IF
!
!     ALLOCATE ARRAYS.
!
      P = INT((NSNPS*TYPED_PEOPLE)*VALIDATION_FRACTION)+1
!
!     READ IN THE FIRST 3 SUBWINDOWS AND SET WEIGHTS.
!
      SNP_READ_START=M
      SNP_READ_END=M+NSNPS-1
      CALL READ_SNP_MATRIX(SNP_FREQUENCY(SNP_READ_START:SNP_READ_END),X,&
        SNP_READ_END,SNP_READ_START,TYPED_PEOPLE)
!     IN THIS IMPLEMENTATION WE ASSUME W IS 0 OR 1.
!     WE WILL NEED TO CHANGE THAT FOR SEQUENCE DATA.
      WHERE (X>=ABSENT)
         W = ZERO
      ELSEWHERE
         W = ONE
      END WHERE
!
!     COUNT THE NUMBER OF VALIDATION ENTRIES.
!
      P = COUNT(W>ZERO)
      P = INT(P*VALIDATION_FRACTION) 
!
!     IMPUTE THE FIRST SUBWINDOW
!     
      COLUMN_OMIT(1:Q) = (/(I,I=1,Q)/)
      CALL FETCH_VALIDATION_ENTRIES(W,COLUMN(1:P),ROW(1:P),COLUMN_OMIT(1:Q),&
        TYPED_PEOPLE,NSNPS,P,Q)

!      IF (MINVAL(COLUMN(1:P)) > 0 .AND. MAXVAL(COLUMN(1:P)) < NSNPS+1) PRINT *, "***VALIDATION COLUMNS ARE LEGIT."
!      IF (MINVAL(ROW(1:P)) > 0 .AND. MAXVAL(ROW(1:P)) < TYPED_PEOPLE+1) PRINT *, "***VALIDATION ROWS ARE LEGIT."

      CALL IMPUTE_WINDOW(W,X,Z,COLUMN(1:P),ROW(1:P),RHO,TYPED_PEOPLE,NSNPS,P)

      CALL FILL_IN(W,X,Z,COLUMN_OMIT(1:Q),TYPED_PEOPLE,NSNPS,Q)

      SNP_WRITE_START = M
      SNP_WRITE_END = M+Q-1
      CALL OUTPUT_SNP_IMPUTATIONS(SNP_FREQUENCY(SNP_WRITE_START:SNP_WRITE_END), &
        Z(:,1:Q),SNP_WRITE_END,SNP_WRITE_START,TYPED_PEOPLE)

      PRINT *, "IMPUTED SNPS:", SNP_WRITE_START, "to", SNP_WRITE_END
!
!     IMPUTE SECOND SUBWINDOW
!
      COLUMN_OMIT(1:Q) = (/(I,I=Q+1,2*Q)/)
      CALL FETCH_VALIDATION_ENTRIES(W,COLUMN(1:P),ROW(1:P),COLUMN_OMIT(1:Q),TYPED_PEOPLE,NSNPS,P,Q)
!      IF (MINVAL(COLUMN(1:P)) > 0 .AND. MAXVAL(COLUMN(1:P)) < NSNPS+1) PRINT *, "***VALIDATION COLUMNS ARE LEGIT."
!      IF (MINVAL(ROW(1:P)) > 0 .AND. MAXVAL(ROW(1:P)) < TYPED_PEOPLE+1) PRINT *, "***VALIDATION ROWS ARE LEGIT."

      CALL IMPUTE_WINDOW(W,X,Z,COLUMN(1:P),ROW(1:P),RHO,TYPED_PEOPLE,NSNPS,P)
      CALL FILL_IN(W,X,Z,COLUMN_OMIT(1:Q),TYPED_PEOPLE,NSNPS,Q)
      SNP_WRITE_START = M+Q
      SNP_WRITE_END = M+2*Q-1
      CALL OUTPUT_SNP_IMPUTATIONS(SNP_FREQUENCY(SNP_WRITE_START:SNP_WRITE_END), &
        Z(:,Q+1:2*Q),SNP_WRITE_END,SNP_WRITE_START,TYPED_PEOPLE)
      PRINT *, "IMPUTED SNPS:", SNP_WRITE_START, "to", SNP_WRITE_END
!
!     SHIFT ELEMENTS IN X AND W
!
      X(:,1:2*Q) = X(:,Q+1:NSNPS)
      W(:,1:2*Q) = W(:,Q+1:NSNPS)
!
!     MAIN LOOP
!
      DO J=1,N_SHIFTS
!
!     READ IN NEXT SET OF SUBWINDOWS OF SNPS AND WEIGHTS
!        
         SNP_READ_START=M+(J+2)*Q
         SNP_READ_END=M+(J+3)*Q-1
         CALL READ_SNP_MATRIX(SNP_FREQUENCY(SNP_READ_START:SNP_READ_END),X(:,2*Q+1:NSNPS), &
            SNP_READ_END,SNP_READ_START,TYPED_PEOPLE)
         WHERE (X(:,2*Q+1:NSNPS)>=ABSENT)
            W(:,2*Q+1:NSNPS) = ZERO
         ELSEWHERE
            W(:,2*Q+1:NSNPS) = ONE
         END WHERE
         P = COUNT(W>ZERO)
         P = INT(P*VALIDATION_FRACTION)       
!
!     IMPUTE SUBWINDOW
!
         COLUMN_OMIT(1:Q) = (/ (I,I=Q+1,2*Q) /)
         CALL FETCH_VALIDATION_ENTRIES(W,COLUMN(1:P),ROW(1:P),COLUMN_OMIT(1:Q),TYPED_PEOPLE,NSNPS,P,Q)
!         IF (MINVAL(COLUMN(1:P)) > 0 .AND. MAXVAL(COLUMN(1:P)) < NSNPS+1) PRINT *, "***VALIDATION COLUMNS ARE LEGIT."
!         IF (MINVAL(ROW(1:P)) > 0 .AND. MAXVAL(ROW(1:P)) < TYPED_PEOPLE+1) PRINT *, "***VALIDATION ROWS ARE LEGIT."
         CALL IMPUTE_WINDOW(W,X,Z,COLUMN(1:P),ROW(1:P),RHO,TYPED_PEOPLE,NSNPS,P)
         CALL FILL_IN(W,X,Z,COLUMN_OMIT(1:Q),TYPED_PEOPLE,NSNPS,Q)
         SNP_WRITE_START=M+(J+1)*Q
         SNP_WRITE_END=M+(J+2)*Q-1
         CALL OUTPUT_SNP_IMPUTATIONS(SNP_FREQUENCY(SNP_WRITE_START:SNP_WRITE_END), &
            Z(:,Q+1:2*Q),SNP_WRITE_END,SNP_WRITE_START,TYPED_PEOPLE)
         PRINT *, "IMPUTED SNPS:", SNP_WRITE_START, "to", SNP_WRITE_END
!
!     SHIFT ELEMENTS IN X AND W, FOR ALL SUBWINDOWS EXCEPT THE LAST
!
         IF (J<N_SHIFTS) THEN
            X(:,1:2*Q) = X(:,Q+1:NSNPS)
            W(:,1:2*Q) = W(:,Q+1:NSNPS)
         END IF
!         PRINT '(1X, "J = ", I2, ", SNP_WRITE_START = ", I3, ", SNP_WRITE_END = ", I3)', J, SNP_WRITE_START, SNP_WRITE_END
      END DO
!      PRINT *, "STARTING LAST SUBWINDOW"
!
!     LAST SUBWINDOW
!      
      SNP_READ_START = SNP_WRITE_END+Q+1
      SNP_READ_END = N
      IF (SNP_READ_END.EQ.SNP_READ_START-1) THEN
        P = COUNT(W>ZERO)
        P = INT(P*VALIDATION_FRACTION)
        COLUMN_OMIT(1:Q) = (/(I,I=2*Q+1,NSNPS)/)
        CALL FETCH_VALIDATION_ENTRIES(W,COLUMN(1:P),ROW(1:P),COLUMN_OMIT(1:Q),TYPED_PEOPLE,NSNPS,P,Q)
        CALL IMPUTE_WINDOW(W,X,Z,COLUMN(1:P),ROW(1:P),RHO,TYPED_PEOPLE,NSNPS,P)
        CALL FILL_IN(W,X,Z,COLUMN_OMIT(1:Q),TYPED_PEOPLE,NSNPS,Q)

        SNP_WRITE_START = M+(N_SHIFTS+2)*Q
        SNP_WRITE_END = SNP_READ_END
        CALL OUTPUT_SNP_IMPUTATIONS(SNP_FREQUENCY(SNP_WRITE_START:SNP_WRITE_END), &
            Z(:,2*Q+1:NSNPS),SNP_WRITE_END,SNP_WRITE_START,TYPED_PEOPLE)
        PRINT *, "IMPUTED SNPS", SNP_WRITE_START, SNP_WRITE_END
      END IF

      IF (SNP_READ_START.LE.SNP_READ_END) THEN
        R = SNP_READ_END-SNP_READ_START+1
        NSNPS = 3*Q+R
        PRINT *, "NSNPS, R", NSNPS, R

        ALLOCATE(W_LAST(TYPED_PEOPLE,NSNPS))
        ALLOCATE(X_LAST(TYPED_PEOPLE,NSNPS))
        ALLOCATE(Z_LAST(TYPED_PEOPLE,NSNPS))
        X_LAST(:,1:3*Q) = X(:,1:3*Q)
        W_LAST(:,1:3*Q) = W(:,1:3*Q)
!
!     READ DATA INTO X_LAST(:,3*Q+1:NSNPS)
!
        CALL READ_SNP_MATRIX(SNP_FREQUENCY(SNP_READ_START:SNP_READ_END),X_LAST(:,3*Q+1:3*Q+R),&
            SNP_READ_END,SNP_READ_START,TYPED_PEOPLE)
        WHERE (X_LAST(:,2*Q+1:NSNPS)>=ABSENT)
            W_LAST(:,2*Q+1:NSNPS) = ZERO
        ELSEWHERE
            W_LAST(:,2*Q+1:NSNPS) = ONE
        END WHERE
        P = COUNT(W_LAST>ZERO)
        P = INT(P*VALIDATION_FRACTION)

        COLUMN_OMIT(1:Q+R) = (/(I,I=2*Q+1,NSNPS)/)
        CALL FETCH_VALIDATION_ENTRIES(W_LAST,COLUMN(1:P),ROW(1:P),COLUMN_OMIT(1:Q+R),TYPED_PEOPLE,NSNPS,P,Q+R)
        CALL IMPUTE_WINDOW(W_LAST,X_LAST,Z_LAST,COLUMN(1:P),ROW(1:P),RHO,TYPED_PEOPLE,NSNPS,P)
        CALL FILL_IN(W_LAST,X_LAST, Z_LAST,COLUMN_OMIT(1:Q+R),TYPED_PEOPLE,NSNPS,Q+R)

        SNP_WRITE_START = M+(N_SHIFTS+2)*Q
        SNP_WRITE_END = SNP_READ_END
        CALL OUTPUT_SNP_IMPUTATIONS(SNP_FREQUENCY(SNP_WRITE_START:SNP_WRITE_END), &
            Z_LAST(:,2*Q+1:NSNPS),SNP_WRITE_END,SNP_WRITE_START,TYPED_PEOPLE)
        PRINT *, "IMPUTED SNPS", SNP_WRITE_START, SNP_WRITE_END
!
!     DEALLOCATE ARRAYS.
!
        DEALLOCATE(W_LAST)
        DEALLOCATE(X_LAST)
        DEALLOCATE(Z_LAST)

      END IF
      END SUBROUTINE SLIDING_WINDOW
!
      SUBROUTINE FETCH_VALIDATION_ENTRIES(W,COLUMN,ROW,COLUMN_OMIT,M,N,P,Q)
!
!     THIS SUBROUTINE DETERMINES WHICH ELEMENTS WILL SERVE AS THE
!     VALIDATION ENTRIES IN THE MATRIX X FOR SELECTING THE REGULARIZATION
!     PARAMETER. COLUMN_OMIT DENOTES COLUMNS THAT ARE INELGIBLE FOR INCLUSION 
!     IN THE VALIDATION SET. P DENOTES THE SIZE OF THE VALIDATION SET.
!     Q DENOTES THE SIZE OF THE EXCLUSION SET.
!
        IMPLICIT NONE
        INTEGER :: I,J,K,M,N,P,Q
        REAL(KIND=DBLE_PREC) :: UNIFORM
        INTEGER, DIMENSION(P) :: COLUMN,ROW
        INTEGER, DIMENSION(Q) :: COLUMN_OMIT
        INTEGER, DIMENSION(M*N) :: COLUMN_ELIGIBLE,ROW_ELIGIBLE
        REAL(KIND=DBLE_PREC), DIMENSION(M,N) :: W,Z
!        
!     BLANK OUT INELIGIBLE ROWS.
!
        Z = W
        Z(:,COLUMN_OMIT) = ZERO
!
!     IDENTIFY ELIGIBLE ELEMENTS.
!
        K = 0
        DO I = 1,M
           DO J = 1,N
              IF (Z(I,J)>ZERO) THEN
                 K = K+1
                 ROW_ELIGIBLE(K) = I
                 COLUMN_ELIGIBLE(K) = J
              END IF
           END DO
        END DO
!
!     RANDOMLY DRAW P VALIDATION ELEMENTS FROM THE K ELIGIBLE ELEMENTS.
!
      DO I = 1,P
         J = RANDOM_INTEGER(K-I+1)+I-1
         CALL SWAP(ROW_ELIGIBLE(I),ROW_ELIGIBLE(J))
         CALL SWAP(COLUMN_ELIGIBLE(I),COLUMN_ELIGIBLE(J))
         ROW(I) = ROW_ELIGIBLE(I)
         COLUMN(I) = COLUMN_ELIGIBLE(I)
      END DO
      END SUBROUTINE FETCH_VALIDATION_ENTRIES
!
      SUBROUTINE GET_MAX_LAMBDA_SVDCMP(Z,MAX_LAMBDA,M,N)
!
!     THIS SUBROUTINE CALCULATES THE LARGEST SINGULAR VALUE OF THE
!     M-by-N MATRIX Z USING SVDCMP.
!
      IMPLICIT NONE
      INTEGER :: M,N
      REAL(KIND=DBLE_PREC) :: Z(M,N), MAX_LAMBDA
      INTEGER :: INFO, LWORK, I, R
      REAL(KIND=DBLE_PREC), DIMENSION(N) :: SINGULAR
      REAL(KIND=DBLE_PREC) :: U(M,N), VT(N,N), S(N)

      CALL SVDCMP(Z,SINGULAR,VT,M,N)
      MAX_LAMBDA = MAXVAL(SINGULAR)
      END SUBROUTINE GET_MAX_LAMBDA_SVDCMP
!
    SUBROUTINE FILL_IN(W,X,Z,COLUMN_OMIT,M,N,Q)
!
!     FILL IN THE SELECTED MISSING ENTRIES (TYPICALLY MIDDLE THIRD) OF
!     X IMPUTED IN Z.
!
      IMPLICIT NONE
      INTEGER :: I,J,K,M,N,Q
      INTEGER, DIMENSION(Q) :: COLUMN_OMIT
      REAL(KIND=DBLE_PREC), DIMENSION(M,N) :: W,X,Z
!
      DO I = 1,Q
         K = COLUMN_OMIT(I)
         DO J = 1,M
            IF (W(J,K)<=ZERO) THEN
                X(J,K) = Z(J,K)
                W(J,K)=ONE
            END IF 
         END DO
      END DO
      END SUBROUTINE FILL_IN
!
      SUBROUTINE READ_SNP_MATRIX(SNP_FREQUENCY,X,SNP_END,SNP_START,&
         TYPED_PEOPLE)
!
!     THIS SUBROUTINE READS A BLOCK OF UNPHASED SNP GENOTYPES INTO
!     THE DATA MATRIX X.  X TAKES THE VALUES 0 (HOMOZYGOUS IN FIRST 
!     ALLELE), 1 (HETEROZYGOUS), 2 (HOMOZYGOUS IN SECOND ALLELE), 
!     AND ABSENT.  IN THE PROCESS ALSO COMPUTE ALLELE FREQUENCIES.
!
      IMPLICIT NONE
      INTEGER :: A,B,I,J,K,SNP,SNP_END,SNP_START,TYPED_PEOPLE
      INTEGER, DIMENSION(PEOPLE) :: SNP_GENOTYPE
      REAL(KIND=DBLE_PREC), DIMENSION(SNP_START:SNP_END) :: SNP_FREQUENCY
      REAL(KIND=DBLE_PREC), DIMENSION(TYPED_PEOPLE,SNP_START:SNP_END) :: X
!
!     LOOP OVER THE RELEVANT SNPS AND RETRIEVE SNP GENOTYPES.
!
      DO SNP = SNP_START,SNP_END
         CALL FETCH_SNP_GENOTYPES(SNP,SNP_GENOTYPE)
!
!     LOOP OVER THE RELEVANT PEOPLE AND INSERT THE RESULTS INTO X.
!
         A = 0
         B = 0
         J = 0
         DO I = 1,PEOPLE
            IF (PERSON(I)%TYPED_AT_SNPS) THEN
               J = J+1
               K = SNP_GENOTYPE(I)
               IF (K<3) THEN
                  A = A+K
                  B = B+2
                  X(J,SNP) = REAL(K,KIND=DBLE_PREC)   
               ELSE
                  X(J,SNP) = ABSENT
               END IF
            END IF
         END DO
!
!     COMPUTE THE FREQUENCY OF THE FIRST ALLELE.
!
         IF (B>0) THEN
            SNP_FREQUENCY(SNP) = REAL(A,KIND=DBLE_PREC)/REAL(B,KIND=DBLE_PREC)
         ELSE
            SNP_FREQUENCY(SNP) = ZERO
         END IF         
      END DO
      END SUBROUTINE READ_SNP_MATRIX
!
      SUBROUTINE OUTPUT_SNP_IMPUTATIONS(SNP_FREQUENCY,Z,SNP_END, &
         SNP_START,TYPED_PEOPLE)
!
!     THIS SUBROUTINE ORCHESTRATES THE OUTPUT OF THE IMPUTED SNP
!     GENOTYPES FOR A BLOCK OF SNPS.
!    
      IMPLICIT NONE
      INTEGER :: SNP,SNP_END,SNP_GENOTYPE,SNP_START,TYPED_PEOPLE
      REAL(KIND=DBLE_PREC) :: F,PRIOR_TOTAL,VAR
      INTEGER, DIMENSION(TYPED_PEOPLE) :: ASSIGNED
      REAL(KIND=DBLE_PREC), DIMENSION(3) :: ADMIX,MEAN,PRIOR_COUNT
      REAL(KIND=DBLE_PREC), DIMENSION(SNP_START:SNP_END) :: SNP_FREQUENCY
      REAL(KIND=DBLE_PREC), DIMENSION(TYPED_PEOPLE,SNP_START:SNP_END) :: Z, ZHAT
!
!     LOOP OVER THE RELEVANT SNPS AND INSERT SNP GENOTYPES INTO THE BINARY
!     FILE.
!
      PRIOR_TOTAL = REAL(TYPED_PEOPLE,KIND=DBLE_PREC)/TEN
      ZHAT = Z
      CALL PROJECT_TO_BOX(ZHAT,ZERO,TYPED_PEOPLE,SNP_END-SNP_START+1,TWO)
      DO SNP = SNP_START,SNP_END
!
!     PREPARE FOR EM CLUSTERING TO CORRECT FOR MATRIX SHRINKAGE.  NOTE
!     THE USE OF HARDY-WEINBERG FREQUENCIES AS PRIORS AND INITIAL VALUES.
!
         F = SNP_FREQUENCY(SNP)
         ADMIX(1) = F**2
         ADMIX(2) = TWO*F*(ONE-F)
         ADMIX(3) = (ONE-F)**2
         MEAN(1) = ZERO
         MEAN(2) = ONE
         MEAN(3) = TWO
         VAR = ONE
         PRIOR_COUNT = PRIOR_TOTAL*ADMIX
!
!     CLUSTER THE IMPUTE VALUES AND ASSIGN PEOPLE TO CLUSTERS.
!
         CALL EM_ADMIXTURE(ADMIX,ASSIGNED,TEN*MEAN,PRIOR_COUNT,VAR,TEN*ZHAT(:,SNP),TYPED_PEOPLE,3)
!
!     TRANSLATE CLUSTER ASSIGNMENTS INTO SNP GENOTYPES.
!
         CALL TRANSFER_SNP_TO_BINARY(ASSIGNED,SNP,TYPED_PEOPLE)
      END DO
      END SUBROUTINE OUTPUT_SNP_IMPUTATIONS
!
      SUBROUTINE PROJECT_TO_BOX(Z,LB,M,N,UB)
!
!     PROJECT MATRIX ENTRIES TO [0,2]
!
        IMPLICIT NONE
        INTEGER :: I,J,M,N
        REAL(KIND=DBLE_PREC) :: LB,UB
        REAL(KIND=DBLE_PREC), DIMENSION(M,N):: Z

        DO I=1,M
            DO J=1,N
                Z(I,J) = MIN(MAX(Z(I,J),LB),UB)
            END DO
        END DO

      END SUBROUTINE PROJECT_TO_BOX
!
      SUBROUTINE TRANSFER_SNP_TO_BINARY(ASSIGNED,SNP,TYPED_PEOPLE)
!
!     THIS SUBROUTINE INSERTS UNPHASED GENOTYPES AT A GIVEN SNP INTO THE
!     BINARY SNP ARRAY. ASSIGNED TAKES THE VALUES 0 (HOMOZYGOUS IN FIRST
!     ALLELE), 1 (HETEROZYGOUS), AND 2 (HOMOZYGOUS IN SECOND ALLELE).
!
!     IN THE INTERNAL SNP_BIT DATA ARRAY
!     UNPHASED GENOTYPES ARE ENCODED AS
!     00 = HOMOZYGOUS IN FIRST ALLELE;
!     01 = HETEROZYGOUS;
!     10 = HOMOZYGOUS IN SECOND ALLELE;
!     11 = MISSING GENOTYPE.

      IMPLICIT NONE
      INTEGER :: I,J,K,L,SNP,TYPED_PEOPLE
      INTEGER(KIND=1) :: PHENOTYPE
      INTEGER, DIMENSION(TYPED_PEOPLE) :: ASSIGNED
!
!     LOOP OVER THE RELEVANT PEOPLE.
!
      I = GENOTYPE_BIT_LAST_POSITION
      J = 0
      L = 0
      DO K = 1,PEOPLE
         IF (PERSON(K)%TYPED_AT_SNPS) THEN
            L = L+1
            IF (I==GENOTYPE_BIT_LAST_POSITION) THEN
               I = 0
               J = J+1
            ELSE
               I = I+BITS_PER_GENOTYPE
            END IF
!
!     CHECK WHETHER THE CURRENT GENOTYPE IS MISSING.  ONLY MISSING
!     GENOTYPES ARE IMPUTED.
!  
            PHENOTYPE = ZERO_SINGLE_BYTE
            CALL MVBITS(SNP_BIT(J,SNP),I+1,1,PHENOTYPE,0)
            CALL MVBITS(SNP_BIT(J,SNP),I  ,1,PHENOTYPE,1)
            IF (PHENOTYPE==THREE_SINGLE_BYTE) THEN
!
!     REPLACE THE MISSING GENOTYPE BY THE IMPUTED GENOTYPE.
!
               PHENOTYPE = INT(ASSIGNED(L)-1,KIND=1)
               CALL MVBITS(PHENOTYPE,0,1,SNP_BIT(J,SNP),I+1)
               CALL MVBITS(PHENOTYPE,1,1,SNP_BIT(J,SNP),I)
            END IF
         END IF  
      END DO
      END SUBROUTINE TRANSFER_SNP_TO_BINARY
!
      SUBROUTINE SHRINK_MATRIX_SVDCMP(Z, LAMBDA, M, N, RANK, TRNORM)
!
!   This function performs singular value thresholding on
!   the matrix Z. It assumes N = min(M,N).
!
      IMPLICIT NONE
      INTEGER :: M, N
      REAL(KIND=DBLE_PREC) :: Z(M,N), LAMBDA
      INTEGER :: I, RANK
      REAL(KIND=DBLE_PREC) :: U(M,N), V(N,N), S(N)
      REAL(KIND=DBLE_PREC) :: ST(N), TRNORM
      U = Z
!
!     Compute SVD
!
      CALL SVDCMP(U,S,V,M,N)
!
!     Soft threshold the singular values.
!
      I = 1
      ST = ZERO
      RANK = 0
      DO I = 1,N
        IF (S(I) > LAMBDA) THEN
            ST(I) = S(I) - LAMBDA
            RANK = RANK + 1
        END IF
      END DO

      IF (RANK > 0) THEN
         DO I = 1,N
            U(:,I) = ST(I)*U(:,I)
         END DO
         Z = MATMUL(U, TRANSPOSE(V))
         TRNORM = SUM(ST)
      ELSE
         Z = ZERO
      END IF
    END SUBROUTINE SHRINK_MATRIX_SVDCMP
!
      SUBROUTINE IMPUTE_WINDOW(W,X,Z,COLUMN,ROW,RHO,M,N,P)
!
!     THIS SUBROUTINE PERFORMS PENALIZED MATRIX COMPLETION ON A 
!     MATRIX WITH M ROWS AND N COLUMNS.  RHO IS A DECREMENT FACTOR
!     FOR REDUCING THE PENALTY CONSTANT. CHOOSE RHO BETWEEN 0 AND 
!     1. THE ARRAYS COLUMN AND ROW INDEX THE VALIDATION SET. P IS 
!     THE NUMBER ELEMENTS IN THIS SET.
!
      IMPLICIT NONE
      INTEGER :: I,ITER,ITER_TOTAL,J,K,M,N,NNZ,P,RANK
      INTEGER :: MAX_ITER,OBSIDX(M*N)
      INTEGER, DIMENSION(P) :: COLUMN,ROW
      REAL(KIND=DBLE_PREC) :: LAMBDA,OBJECTIVE,RHO,RHO_TOL,TOL
      REAL(KIND=DBLE_PREC) :: PREVIOUS_ERROR,VALIDATION_ERROR

      REAL(KIND=DBLE_PREC), DIMENSION(M,N) :: W,WL,X,Z
!
!     MAKE A LOCAL COPY OF W NAMED WL AND MASK THE VALIDATION ENTRIES
!
      WL = W
      DO I = 1,P
         WL(ROW(I),COLUMN(I)) = ZERO
      END DO
!
!     FETCH THE MAXIMUM PENALTY CONSTANT.
!
      CALL GET_MAX_LAMBDA_SVDCMP(WL*X,LAMBDA,M,N)
!
!     FILL IN THE SURROGATE MATRIX WITH OBSERVED VALUES AND ZEROS.
!
      WHERE(WL>ZERO)
         Z = X
     ELSEWHERE
         Z = ZERO
      END WHERE
!
!     CREATE VECTOR OF OBSERVED INDICES
!
      CALL FIND_NONZEROS(M,N,OBSIDX,NNZ,WL)
!
!     LOOP OVER A DECREASING SEQUENCE OF PENALTY VALUES AND FIND A NEARLY
!     OPTIMAL ONE.
!
!     ***TUNABLE PARAMETER***
!      RHO_TOL = TEN**(-4)
      RHO_TOL = TEN**(-3)
      PREVIOUS_ERROR = HUGE(ONE)
      TOL = TEN**(-5)
      MAX_ITER = 1000
      ITER_TOTAL = 0
      DO
!
!     PERFORM MATRIX COMPLETION.
!
         CALL SVT_IMPUTE_NESTEROV(WL,X,Z,LAMBDA,M,N,OBSIDX(1:NNZ),NNZ,RANK,TOL,MAX_ITER,ITER,OBJECTIVE)
         ITER_TOTAL = ITER_TOTAL + ITER
!
!     CALCULATE THE VALIDATION ERROR.
!
         VALIDATION_ERROR = ZERO
         DO I = 1,P
            J = ROW(I)
            K = COLUMN(I)
            VALIDATION_ERROR = VALIDATION_ERROR+ABS(X(J,K)-Z(J,K))
         END DO
         PRINT*,"ITER = ",ITER," OBJ = ",OBJECTIVE,"VALIDATION ERR = ",VALIDATION_ERROR
!
!     EXIT IF NO PROGRESS HAS BEEN MADE IN REDUCING THE ERROR.
!
         IF (VALIDATION_ERROR>(ONE-RHO_TOL)*PREVIOUS_ERROR-RHO_TOL) EXIT
!
!     DECREASE LAMBDA AND TRY AGAIN.
!
         PREVIOUS_ERROR = VALIDATION_ERROR      
         LAMBDA = LAMBDA*RHO
      END DO
      PRINT '(1X, "ITNS = ", I4, ", RANK = ", I3)', ITER_TOTAL, RANK
      END SUBROUTINE IMPUTE_WINDOW     
!
      SUBROUTINE FIND_NONZEROS(M, N, OBSIDX, P, W)
      IMPLICIT NONE
      INTEGER :: ITER, M, N, P
      INTEGER :: OBSIDX(M*N)
      REAL(KIND=DBLE_PREC) :: vecW(M*N), W(M,N)

      CALL VEC(W,vecW,M,N)
      P = 1
      DO ITER = 1,M*N
         IF (vecW(ITER) > ZERO) THEN
            OBSIDX(P) = ITER
            P = P + 1
         END IF
      END DO
      P = P - 1
      END SUBROUTINE FIND_NONZEROS
!
      SUBROUTINE VEC(X,Y,M,N)
      INTEGER :: M, N
      REAL(KIND=DBLE_PREC) :: X(M,N), Y(M*N), Z(M*N,1)

      Z = RESHAPE(X, (/M*N, 1/))
      Y = Z(:,1)

      END SUBROUTINE VEC
!
      SUBROUTINE MATRICIZE(X,Y,M,N)
      INTEGER :: M, N
      REAL(KIND=DBLE_PREC) :: X(M*N), Y(M,N), Z(M*N,1)
      
      Z(:,1) = X
      Y = RESHAPE(Z, (/M, N/))

      END SUBROUTINE MATRICIZE
!
SUBROUTINE SVT_IMPUTE_NESTEROV(W, X, Z, LAMBDA, M, N, OBSIDX, P, RANK, TOL, MAX_ITER, ITER, OBJ)
    IMPLICIT NONE
    INTEGER :: ITER, J, M, MAX_ITER, P, RANK
    INTEGER :: OBSIDX(P), N
    REAL(KIND=DBLE_PREC) :: LOSSD1S(P), RESID(P)
    REAL(KIND=DBLE_PREC) :: A(M,N), S(M,N), W(M,N), X(M,N), Y(M,N), YMINUSS(M,N), Y_OLD(M,N), Z(M,N)
    REAL(KIND=DBLE_PREC) :: vecA(M*N), vecS(M*N), vecW(M*N), vecX(M*N), vecY(M*N), vecYminusS(M*N)
    REAL(KIND=DBLE_PREC) :: ALPHA, ALPHA_OLD, LAMBDA, LOSS_S, OBJ, OBJ_OLD, RIDGEDELTA, SURVAL, TOL, TRNORM
    REAL(KIND=DBLE_PREC) :: MAX_LAMBDA
!
! Initialize
!
    RANK = 0
    ALPHA_OLD = ZERO
    ALPHA = ONE
    OBJ = HUGE(ZERO)
    Y = Z
    Y_OLD = Y
    RIDGEDELTA = ONE
    CALL VEC(X,vecX,M,N)
!
! Main loop
!
    DO ITER = 1,MAX_ITER
        S = Y + ((ALPHA_OLD-ONE)/ALPHA) * (Y-Y_OLD)
        CALL VEC(S,vecS,M,N)
        RESID = vecX(OBSIDX) - vecS(OBSIDX)
        LOSS_S = HALF*SUM(RESID**2)
        LOSSD1S = -RESID
!
! Line search
!
        Y_OLD = Y
        OBJ_OLD = OBJ
        DO J=1,50
            A = S
            CALL VEC(A,vecA,M,N)
            vecA(OBSIDX) = vecA(OBSIDX) - RIDGEDELTA*LOSSD1S
            CALL MATRICIZE(vecA,A,M,N)
            CALL SHRINK_MATRIX_SVDCMP(A, RIDGEDELTA*LAMBDA, M, N, RANK, TRNORM)
            Y = A
            CALL VEC(Y,vecY,M,N)
            RESID = vecX(OBSIDX) - vecY(OBSIDX)
!
! Objective value
!
            OBJ = HALF*SUM(RESID**2) + LAMBDA*TRNORM
!
! Surrogate value
!
            CALL VEC(Y-S,vecYminusS,M,N)
            SURVAL = LOSS_S + SUM(LOSSD1S*vecYminusS(OBSIDX)) + HALF*SUM(vecYminusS**2)/RIDGEDELTA + LAMBDA*TRNORM
!        PRINT *, "ITER ", ITER, "OBJ ", OBJ, "SURVAL ", SURVAL
!
! Line search stopping rule
!
            IF (OBJ.LE.SURVAL) THEN
                EXIT
            ELSE
                RIDGEDELTA = HALF*RIDGEDELTA
            END IF
        END DO
!
! Force descent
!
        IF (OBJ.LE.OBJ_OLD+1E-8) THEN
            IF (ABS(OBJ_OLD-OBJ) < TOL*(ABS(OBJ_OLD) + ONE)) THEN
                EXIT
            END IF
        ELSE
            Y = Y_OLD
            OBJ = OBJ_OLD
        END IF
!     PRINT *, "ITER", ITER, "OBJ = ", OBJ
!
! Update alpha constants
!
        ALPHA_OLD = ALPHA
        ALPHA = HALF*(ONE + SQRT(FOUR+ALPHA_OLD**2))
    END DO
    Z = Y
END SUBROUTINE SVT_IMPUTE_NESTEROV
!
      SUBROUTINE EM_ADMIXTURE(ADMIX,ASSIGNED,MEAN,PRIOR_COUNT,VAR,X, &
         CASES,CLUSTERS)
!
!     THIS SUBROUTINE PERFORMS GAUSSIAN ADMIXTURE ESTIMATION WITH A
!     COMMON VARIANCE AND A DIRICHLET PRIOR ON THE ADMIXTURE PROPORTIONS.
!     INPUT VALUES ARE USED AS INITIAL VALUES. ADMIX CONTAINS THE ADMIXTURE
!     PROPORTIONS, ASSIGNED THE CLUSTER ASSIGNMENTS, MEAN THE CLUSTER 
!     MEANS, PRIOR_COUNT THE DIRICHLET PRIOR, VAR THE COMMON VARIANCE, AND
!     X THE DATA.  AN EM ALGORITHM PROVIDES THE UPDATES. EXIT OCCURS AFTER 
!     A SUFFICIENT NUMBER OF ITERATIONS AND CLUSTER ASSIGNMENTS STABILIZE.      
!
      IMPLICIT NONE
      INTEGER :: CASES,CLUSTERS,I,ITER,J,MIN_ITERATIONS = 10
      REAL(KIND=DBLE_PREC) :: T,TOTAL,VAR
      INTEGER, DIMENSION(CASES) :: ASSIGNED,PREVIOUS_ASSIGNED
      REAL(KIND=DBLE_PREC), DIMENSION(CLUSTERS) :: ADMIX,MEAN
      REAL(KIND=DBLE_PREC), DIMENSION(CLUSTERS) :: POSTERIOR,PRIOR_COUNT
      REAL(KIND=DBLE_PREC), DIMENSION(CLUSTERS,0:2) :: POSTERIOR_SUM
      REAL(KIND=DBLE_PREC), DIMENSION(CASES) :: X
!
!     INITIALIZE VARIABLES.
!
      TOTAL = CASES+SUM(PRIOR_COUNT)
      PREVIOUS_ASSIGNED = 0
!
!     COMPUTE POSTERIOR PROBABILITIES AND POSTERIOR MOMENTS.
!
      DO ITER = 1,100
         POSTERIOR_SUM = ZERO
         DO I = 1,CASES
            T = ZERO
            DO J = 1,CLUSTERS
               POSTERIOR(J) = ADMIX(J)*EXP(-(X(I)-MEAN(J))**2/(TWO*VAR))
               T = T+POSTERIOR(J)
            END DO
            POSTERIOR = POSTERIOR/T
            ASSIGNED(I:I) = MAXLOC(POSTERIOR)
            POSTERIOR_SUM(:,0) = POSTERIOR_SUM(:,0)+POSTERIOR
            POSTERIOR_SUM(:,1) = POSTERIOR_SUM(:,1)+POSTERIOR*X(I)
            POSTERIOR_SUM(:,2) = POSTERIOR_SUM(:,2)+POSTERIOR*X(I)**2 
         END DO
!
!     TEST FOR CONVERGENCE.
!
         IF (ITER>=MIN_ITERATIONS.AND.ALL(ASSIGNED==PREVIOUS_ASSIGNED)) RETURN
         PREVIOUS_ASSIGNED = ASSIGNED
!
!     PERFORM EM UPDATES.
!
         ADMIX = (POSTERIOR_SUM(:,0)+PRIOR_COUNT)/TOTAL
         MEAN = POSTERIOR_SUM(:,1)/POSTERIOR_SUM(:,0)
         VAR = SUM(POSTERIOR_SUM(:,2)-MEAN*POSTERIOR_SUM(:,1))/CASES
      END DO    
      END SUBROUTINE EM_ADMIXTURE
!
      END MODULE MATRIX_COMPLETION_ROUTINES
